const t=(t,n)=>r({get:t,ports:new Set,isChan:!0,info:n}),r=t=>new Proxy(t,{get:n,set:o}),n=(t,r)=>"target"==r?t:t[r],o=(t,r,n)=>"put"==r&&(t.get=n,t.ports.forEach(t=>{t.func()}),!0),e=(t,r)=>{const n={chans:t,func:r};return t.forEach(t=>{t.ports.add(n)}),n},c=t=>{t.chans.forEach(r=>{r.target.ports.delete(t)})},s=(t,r)=>{const n=e(t,()=>{r(),c(n)});return n},a=(r,n)=>{const o=t();return e(r,()=>{const t=n();var r;(0==(r=t)&&!(t=>!!t&&t.constructor&&"Array"==t.constructor.name)(r)||r)&&(o.put=t)}),o},u=(t,r)=>a(t,()=>r(...t.map(t=>t.get))),p=(t,r)=>u([t],t=>r(t)?t:null);export{t as chan,a as chanL,p as filterC,e as listen,s as listenOnce,u as mapC,c as removeListen};
